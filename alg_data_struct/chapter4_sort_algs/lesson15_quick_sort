def quick_sort(nums, low, high):
    if low < high:
        mid_index = partition(nums, low, high)
        quick_sort(nums, low, mid_index -1) #Note that quick_sort is only performed in the items before and after the middle index
        #The reason is that the middle index is ideally in its perfect spot after partition, so you don't have to worry about it
        quick_sort(nums, mid_index +1, high)
        
def partition(nums, low, high):
    pivot = nums[high]
    i = low -1
    for j in range(low, high):
        if nums[j] < pivot:
            i +=1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i+1], nums[high] = nums[high], nums[i+1]
    return i + 1
"""
Quick sort, of all the algorithms learned so far, is the most useful one. It doesn't require a lot of memory and it
is pretty fast. The only possible drawback is if the algorithm consistenly picks low numbers as the pivot, which is up
to chance, really. There are techniques to mitigate this, but there is always a possibility that the algorithm is a bit 
slow, though that's unlikely.
If the list is alaredy sorted, then it becomes O(n^2). It's usually O(n*log(n)), but it depends on how many times
parition() is called. If the pivot is the middle element for every sublist, then the algorithm becomes O(log(n)).

These are the techniques to tackle the O(n^2) issue :
Shuffle input randomly before sorting. This can trivially be done in O(n) time.
Actively find the median of a sample of data from the partition, this can be done in O(1) time.

Another solution is the median of three approach:
Another popular solution is to use the "median of three" approach. Three elements (for example: the first, middle, and last elements) of each partition are chosen and the median is found between them. That item is then used as the pivot.

This approach has less overhead, and also doesn't require randomness to be injected into the function, meaning it can remain deterministic and pure.
It does not require randomness.
"""
